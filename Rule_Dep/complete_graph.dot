digraph CompleteDependencies {
  rankdir=LR;
  
  // Parser rules (blue boxes)
  node [shape=box, fillcolor=lightblue, style=filled];
  "sourceUnit";
  "pragmaDirective";
  "importDirective";
  "importAliases";
  "path";
  "symbolAliases";
  "contractDefinition";
  "interfaceDefinition";
  "libraryDefinition";
  "inheritanceSpecifierList";
  "inheritanceSpecifier";
  "contractBodyElement";
  "namedArgument";
  "callArgumentList";
  "identifierPath";
  "modifierInvocation";
  "visibility";
  "parameterList";
  "parameterDeclaration";
  "constructorDefinition";
  "stateMutability";
  "overrideSpecifier";
  "functionDefinition";
  "modifierDefinition";
  "fallbackFunctionDefinition";
  "receiveFunctionDefinition";
  "structDefinition";
  "structMember";
  "enumDefinition";
  "userDefinedValueTypeDefinition";
  "stateVariableDeclaration";
  "constantVariableDeclaration";
  "eventParameter";
  "eventDefinition";
  "errorParameter";
  "errorDefinition";
  "userDefinableOperator";
  "usingDirective";
  "usingAliases";
  "typeName";
  "elementaryTypeName";
  "functionTypeName";
  "variableDeclaration";
  "dataLocation";
  "expression";
  "assignOp";
  "tupleExpression";
  "inlineArrayExpression";
  "identifier";
  "literal";
  "literalWithSubDenomination";
  "booleanLiteral";
  "stringLiteral";
  "hexStringLiteral";
  "unicodeStringLiteral";
  "numberLiteral";
  "block";
  "uncheckedBlock";
  "statement";
  "simpleStatement";
  "ifStatement";
  "forStatement";
  "whileStatement";
  "doWhileStatement";
  "continueStatement";
  "breakStatement";
  "tryStatement";
  "catchClause";
  "returnStatement";
  "emitStatement";
  "revertStatement";
  "assemblyStatement";
  "assemblyFlags";
  "variableDeclarationList";
  "variableDeclarationTuple";
  "variableDeclarationStatement";
  "expressionStatement";
  "mappingType";
  "mappingKeyType";
  "yulStatement";
  "yulBlock";
  "yulVariableDeclaration";
  "yulAssignment";
  "yulIfStatement";
  "yulForStatement";
  "yulSwitchCase";
  "yulSwitchStatement";
  "yulFunctionDefinition";
  "yulPath";
  "yulFunctionCall";
  "yulBoolean";
  "yulLiteral";
  "yulExpression";

  // Lexer tokens (green ovals)
  node [shape=oval, fillcolor=lightgreen, style=filled];
  "Abstract";
  "Add";
  "Address";
  "And";
  "Anonymous";
  "As";
  "Assembly";
  "AssemblyBlockComma";
  "AssemblyBlockLParen";
  "AssemblyBlockRParen";
  "AssemblyDialect";
  "AssemblyFlagString";
  "AssemblyLBrace";
  "Assign";
  "AssignAdd";
  "AssignBitAnd";
  "AssignBitOr";
  "AssignBitXor";
  "AssignDiv";
  "AssignMod";
  "AssignMul";
  "AssignSar";
  "AssignShl";
  "AssignShr";
  "AssignSub";
  "At";
  "BitAnd";
  "BitNot";
  "BitOr";
  "BitXor";
  "Bool";
  "Break";
  "Bytes";
  "Calldata";
  "Catch";
  "Colon";
  "Comma";
  "Conditional";
  "Constant";
  "Constructor";
  "Continue";
  "Contract";
  "Dec";
  "DecimalNumber";
  "Delete";
  "Div";
  "Do";
  "DoubleArrow";
  "EOF";
  "Else";
  "Emit";
  "EmptyStringLiteral";
  "Enum";
  "Equal";
  "Error";
  "Event";
  "Exp";
  "External";
  "Fallback";
  "False";
  "Fixed";
  "FixedBytes";
  "For";
  "From";
  "Function";
  "Global";
  "GreaterThan";
  "GreaterThanOrEqual";
  "HexNumber";
  "HexString";
  "Identifier";
  "If";
  "Immutable";
  "Import";
  "Inc";
  "Indexed";
  "Interface";
  "Internal";
  "Is";
  "LBrace";
  "LBrack";
  "LParen";
  "Layout";
  "LessThan";
  "LessThanOrEqual";
  "Library";
  "Mapping";
  "Memory";
  "Mod";
  "Modifier";
  "Mul";
  "New";
  "NonEmptyStringLiteral";
  "Not";
  "NotEqual";
  "Or";
  "Override";
  "Payable";
  "Period";
  "Pragma";
  "PragmaSemicolon";
  "PragmaToken";
  "Private";
  "Public";
  "Pure";
  "RBrace";
  "RBrack";
  "RParen";
  "Receive";
  "Return";
  "Returns";
  "Revert";
  "Sar";
  "Semicolon";
  "Shl";
  "Shr";
  "SignedIntegerType";
  "Storage";
  "String";
  "Struct";
  "Sub";
  "SubDenomination";
  "Transient";
  "True";
  "Try";
  "Type";
  "Ufixed";
  "Unchecked";
  "UnicodeStringLiteral";
  "UnsignedIntegerType";
  "Using";
  "View";
  "Virtual";
  "While";
  "YulArrow";
  "YulAssign";
  "YulBreak";
  "YulCase";
  "YulComma";
  "YulContinue";
  "YulDecimalNumber";
  "YulDefault";
  "YulEVMBuiltin";
  "YulFalse";
  "YulFor";
  "YulFunction";
  "YulHexNumber";
  "YulHexStringLiteral";
  "YulIdentifier";
  "YulIf";
  "YulLBrace";
  "YulLParen";
  "YulLeave";
  "YulLet";
  "YulPeriod";
  "YulRBrace";
  "YulRParen";
  "YulStringLiteral";
  "YulSwitch";
  "YulTrue";

  // Parser rule dependencies (solid arrows)
  "sourceUnit" -> "pragmaDirective";
  "sourceUnit" -> "importDirective";
  "sourceUnit" -> "usingDirective";
  "sourceUnit" -> "contractDefinition";
  "sourceUnit" -> "interfaceDefinition";
  "sourceUnit" -> "libraryDefinition";
  "sourceUnit" -> "functionDefinition";
  "sourceUnit" -> "constantVariableDeclaration";
  "sourceUnit" -> "structDefinition";
  "sourceUnit" -> "enumDefinition";
  "sourceUnit" -> "userDefinedValueTypeDefinition";
  "sourceUnit" -> "errorDefinition";
  "sourceUnit" -> "eventDefinition";
  "importDirective" -> "path";
  "importDirective" -> "identifier";
  "importDirective" -> "symbolAliases";
  "importAliases" -> "identifier";
  "symbolAliases" -> "importAliases";
  "contractDefinition" -> "identifier";
  "contractDefinition" -> "expression";
  "contractDefinition" -> "inheritanceSpecifierList";
  "contractDefinition" -> "contractBodyElement";
  "interfaceDefinition" -> "identifier";
  "interfaceDefinition" -> "inheritanceSpecifierList";
  "interfaceDefinition" -> "contractBodyElement";
  "libraryDefinition" -> "identifier";
  "libraryDefinition" -> "contractBodyElement";
  "inheritanceSpecifierList" -> "inheritanceSpecifier";
  "inheritanceSpecifier" -> "identifierPath";
  "inheritanceSpecifier" -> "callArgumentList";
  "contractBodyElement" -> "constructorDefinition";
  "contractBodyElement" -> "functionDefinition";
  "contractBodyElement" -> "modifierDefinition";
  "contractBodyElement" -> "fallbackFunctionDefinition";
  "contractBodyElement" -> "receiveFunctionDefinition";
  "contractBodyElement" -> "structDefinition";
  "contractBodyElement" -> "enumDefinition";
  "contractBodyElement" -> "userDefinedValueTypeDefinition";
  "contractBodyElement" -> "stateVariableDeclaration";
  "contractBodyElement" -> "eventDefinition";
  "contractBodyElement" -> "errorDefinition";
  "contractBodyElement" -> "usingDirective";
  "namedArgument" -> "identifier";
  "namedArgument" -> "expression";
  "callArgumentList" -> "expression";
  "callArgumentList" -> "namedArgument";
  "identifierPath" -> "identifier";
  "modifierInvocation" -> "identifierPath";
  "modifierInvocation" -> "callArgumentList";
  "parameterList" -> "parameterDeclaration";
  "parameterDeclaration" -> "typeName";
  "parameterDeclaration" -> "dataLocation";
  "parameterDeclaration" -> "identifier";
  "constructorDefinition" -> "parameterList";
  "constructorDefinition" -> "modifierInvocation";
  "constructorDefinition" -> "block";
  "overrideSpecifier" -> "identifierPath";
  "functionDefinition" -> "identifier";
  "functionDefinition" -> "parameterList";
  "functionDefinition" -> "visibility";
  "functionDefinition" -> "stateMutability";
  "functionDefinition" -> "modifierInvocation";
  "functionDefinition" -> "overrideSpecifier";
  "functionDefinition" -> "block";
  "modifierDefinition" -> "identifier";
  "modifierDefinition" -> "parameterList";
  "modifierDefinition" -> "overrideSpecifier";
  "modifierDefinition" -> "block";
  "fallbackFunctionDefinition" -> "parameterList";
  "fallbackFunctionDefinition" -> "stateMutability";
  "fallbackFunctionDefinition" -> "modifierInvocation";
  "fallbackFunctionDefinition" -> "overrideSpecifier";
  "fallbackFunctionDefinition" -> "block";
  "receiveFunctionDefinition" -> "modifierInvocation";
  "receiveFunctionDefinition" -> "overrideSpecifier";
  "receiveFunctionDefinition" -> "block";
  "structDefinition" -> "identifier";
  "structDefinition" -> "structMember";
  "structMember" -> "typeName";
  "structMember" -> "identifier";
  "enumDefinition" -> "identifier";
  "userDefinedValueTypeDefinition" -> "identifier";
  "userDefinedValueTypeDefinition" -> "elementaryTypeName";
  "stateVariableDeclaration" -> "typeName";
  "stateVariableDeclaration" -> "overrideSpecifier";
  "stateVariableDeclaration" -> "identifier";
  "stateVariableDeclaration" -> "expression";
  "constantVariableDeclaration" -> "typeName";
  "constantVariableDeclaration" -> "identifier";
  "constantVariableDeclaration" -> "expression";
  "eventParameter" -> "typeName";
  "eventParameter" -> "identifier";
  "eventDefinition" -> "identifier";
  "eventDefinition" -> "eventParameter";
  "errorParameter" -> "typeName";
  "errorParameter" -> "identifier";
  "errorDefinition" -> "identifier";
  "errorDefinition" -> "errorParameter";
  "usingDirective" -> "identifierPath";
  "usingDirective" -> "usingAliases";
  "usingDirective" -> "typeName";
  "usingAliases" -> "identifierPath";
  "usingAliases" -> "userDefinableOperator";
  "typeName" -> "elementaryTypeName";
  "typeName" -> "functionTypeName";
  "typeName" -> "mappingType";
  "typeName" -> "identifierPath";
  "typeName" -> "typeName" [color=red, penwidth=2];
  "typeName" -> "expression";
  "functionTypeName" -> "parameterList";
  "functionTypeName" -> "visibility";
  "functionTypeName" -> "stateMutability";
  "variableDeclaration" -> "typeName";
  "variableDeclaration" -> "dataLocation";
  "variableDeclaration" -> "identifier";
  "expression" -> "expression" [color=red, penwidth=2];
  "expression" -> "identifier";
  "expression" -> "namedArgument";
  "expression" -> "callArgumentList";
  "expression" -> "typeName";
  "expression" -> "assignOp";
  "expression" -> "tupleExpression";
  "expression" -> "inlineArrayExpression";
  "expression" -> "literal";
  "expression" -> "literalWithSubDenomination";
  "expression" -> "elementaryTypeName";
  "tupleExpression" -> "expression";
  "inlineArrayExpression" -> "expression";
  "literal" -> "stringLiteral";
  "literal" -> "numberLiteral";
  "literal" -> "booleanLiteral";
  "literal" -> "hexStringLiteral";
  "literal" -> "unicodeStringLiteral";
  "literalWithSubDenomination" -> "numberLiteral";
  "block" -> "statement";
  "block" -> "uncheckedBlock";
  "uncheckedBlock" -> "block";
  "statement" -> "block";
  "statement" -> "simpleStatement";
  "statement" -> "ifStatement";
  "statement" -> "forStatement";
  "statement" -> "whileStatement";
  "statement" -> "doWhileStatement";
  "statement" -> "continueStatement";
  "statement" -> "breakStatement";
  "statement" -> "tryStatement";
  "statement" -> "returnStatement";
  "statement" -> "emitStatement";
  "statement" -> "revertStatement";
  "statement" -> "assemblyStatement";
  "simpleStatement" -> "variableDeclarationStatement";
  "simpleStatement" -> "expressionStatement";
  "ifStatement" -> "expression";
  "ifStatement" -> "statement";
  "forStatement" -> "simpleStatement";
  "forStatement" -> "expressionStatement";
  "forStatement" -> "expression";
  "forStatement" -> "statement";
  "whileStatement" -> "expression";
  "whileStatement" -> "statement";
  "doWhileStatement" -> "statement";
  "doWhileStatement" -> "expression";
  "tryStatement" -> "expression";
  "tryStatement" -> "parameterList";
  "tryStatement" -> "block";
  "tryStatement" -> "catchClause";
  "catchClause" -> "identifier";
  "catchClause" -> "parameterList";
  "catchClause" -> "block";
  "returnStatement" -> "expression";
  "emitStatement" -> "expression";
  "emitStatement" -> "callArgumentList";
  "revertStatement" -> "expression";
  "revertStatement" -> "callArgumentList";
  "assemblyStatement" -> "assemblyFlags";
  "assemblyStatement" -> "yulStatement";
  "variableDeclarationList" -> "variableDeclaration";
  "variableDeclarationTuple" -> "variableDeclaration";
  "variableDeclarationStatement" -> "variableDeclaration";
  "variableDeclarationStatement" -> "expression";
  "variableDeclarationStatement" -> "variableDeclarationTuple";
  "expressionStatement" -> "expression";
  "mappingType" -> "mappingKeyType";
  "mappingType" -> "identifier";
  "mappingType" -> "typeName";
  "mappingKeyType" -> "elementaryTypeName";
  "mappingKeyType" -> "identifierPath";
  "yulStatement" -> "yulBlock";
  "yulStatement" -> "yulVariableDeclaration";
  "yulStatement" -> "yulAssignment";
  "yulStatement" -> "yulFunctionCall";
  "yulStatement" -> "yulIfStatement";
  "yulStatement" -> "yulForStatement";
  "yulStatement" -> "yulSwitchStatement";
  "yulStatement" -> "yulFunctionDefinition";
  "yulBlock" -> "yulStatement";
  "yulVariableDeclaration" -> "yulExpression";
  "yulVariableDeclaration" -> "yulFunctionCall";
  "yulAssignment" -> "yulPath";
  "yulAssignment" -> "yulExpression";
  "yulAssignment" -> "yulFunctionCall";
  "yulIfStatement" -> "yulExpression";
  "yulIfStatement" -> "yulBlock";
  "yulForStatement" -> "yulBlock";
  "yulForStatement" -> "yulExpression";
  "yulSwitchCase" -> "yulLiteral";
  "yulSwitchCase" -> "yulBlock";
  "yulSwitchStatement" -> "yulExpression";
  "yulSwitchStatement" -> "yulSwitchCase";
  "yulSwitchStatement" -> "yulBlock";
  "yulFunctionDefinition" -> "yulBlock";
  "yulFunctionCall" -> "yulExpression";
  "yulLiteral" -> "yulBoolean";
  "yulExpression" -> "yulPath";
  "yulExpression" -> "yulFunctionCall";
  "yulExpression" -> "yulLiteral";

  // Lexer token dependencies (dashed arrows)
  "sourceUnit" -> "EOF" [style=dashed, color=gray];
  "pragmaDirective" -> "Pragma" [style=dashed, color=gray];
  "pragmaDirective" -> "PragmaToken" [style=dashed, color=gray];
  "pragmaDirective" -> "PragmaSemicolon" [style=dashed, color=gray];
  "importDirective" -> "Import" [style=dashed, color=gray];
  "importDirective" -> "As" [style=dashed, color=gray];
  "importDirective" -> "From" [style=dashed, color=gray];
  "importDirective" -> "Mul" [style=dashed, color=gray];
  "importDirective" -> "Semicolon" [style=dashed, color=gray];
  "importAliases" -> "As" [style=dashed, color=gray];
  "path" -> "NonEmptyStringLiteral" [style=dashed, color=gray];
  "symbolAliases" -> "LBrace" [style=dashed, color=gray];
  "symbolAliases" -> "Comma" [style=dashed, color=gray];
  "symbolAliases" -> "RBrace" [style=dashed, color=gray];
  "contractDefinition" -> "Abstract" [style=dashed, color=gray];
  "contractDefinition" -> "Contract" [style=dashed, color=gray];
  "contractDefinition" -> "Layout" [style=dashed, color=gray];
  "contractDefinition" -> "At" [style=dashed, color=gray];
  "contractDefinition" -> "LBrace" [style=dashed, color=gray];
  "contractDefinition" -> "RBrace" [style=dashed, color=gray];
  "interfaceDefinition" -> "Interface" [style=dashed, color=gray];
  "interfaceDefinition" -> "LBrace" [style=dashed, color=gray];
  "interfaceDefinition" -> "RBrace" [style=dashed, color=gray];
  "libraryDefinition" -> "Library" [style=dashed, color=gray];
  "libraryDefinition" -> "LBrace" [style=dashed, color=gray];
  "libraryDefinition" -> "RBrace" [style=dashed, color=gray];
  "inheritanceSpecifierList" -> "Is" [style=dashed, color=gray];
  "inheritanceSpecifierList" -> "Comma" [style=dashed, color=gray];
  "namedArgument" -> "Colon" [style=dashed, color=gray];
  "callArgumentList" -> "LParen" [style=dashed, color=gray];
  "callArgumentList" -> "Comma" [style=dashed, color=gray];
  "callArgumentList" -> "LBrace" [style=dashed, color=gray];
  "callArgumentList" -> "RBrace" [style=dashed, color=gray];
  "callArgumentList" -> "RParen" [style=dashed, color=gray];
  "identifierPath" -> "Period" [style=dashed, color=gray];
  "visibility" -> "Internal" [style=dashed, color=gray];
  "visibility" -> "External" [style=dashed, color=gray];
  "visibility" -> "Private" [style=dashed, color=gray];
  "visibility" -> "Public" [style=dashed, color=gray];
  "parameterList" -> "Comma" [style=dashed, color=gray];
  "constructorDefinition" -> "Constructor" [style=dashed, color=gray];
  "constructorDefinition" -> "LParen" [style=dashed, color=gray];
  "constructorDefinition" -> "RParen" [style=dashed, color=gray];
  "constructorDefinition" -> "Payable" [style=dashed, color=gray];
  "constructorDefinition" -> "Internal" [style=dashed, color=gray];
  "constructorDefinition" -> "Public" [style=dashed, color=gray];
  "stateMutability" -> "Pure" [style=dashed, color=gray];
  "stateMutability" -> "View" [style=dashed, color=gray];
  "stateMutability" -> "Payable" [style=dashed, color=gray];
  "overrideSpecifier" -> "Override" [style=dashed, color=gray];
  "overrideSpecifier" -> "LParen" [style=dashed, color=gray];
  "overrideSpecifier" -> "Comma" [style=dashed, color=gray];
  "overrideSpecifier" -> "RParen" [style=dashed, color=gray];
  "functionDefinition" -> "Function" [style=dashed, color=gray];
  "functionDefinition" -> "Fallback" [style=dashed, color=gray];
  "functionDefinition" -> "Receive" [style=dashed, color=gray];
  "functionDefinition" -> "LParen" [style=dashed, color=gray];
  "functionDefinition" -> "RParen" [style=dashed, color=gray];
  "functionDefinition" -> "Virtual" [style=dashed, color=gray];
  "functionDefinition" -> "Returns" [style=dashed, color=gray];
  "functionDefinition" -> "Semicolon" [style=dashed, color=gray];
  "modifierDefinition" -> "Modifier" [style=dashed, color=gray];
  "modifierDefinition" -> "LParen" [style=dashed, color=gray];
  "modifierDefinition" -> "RParen" [style=dashed, color=gray];
  "modifierDefinition" -> "Virtual" [style=dashed, color=gray];
  "modifierDefinition" -> "Semicolon" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "Fallback" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "LParen" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "RParen" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "External" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "Virtual" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "Returns" [style=dashed, color=gray];
  "fallbackFunctionDefinition" -> "Semicolon" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "Receive" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "LParen" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "RParen" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "External" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "Payable" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "Virtual" [style=dashed, color=gray];
  "receiveFunctionDefinition" -> "Semicolon" [style=dashed, color=gray];
  "structDefinition" -> "Struct" [style=dashed, color=gray];
  "structDefinition" -> "LBrace" [style=dashed, color=gray];
  "structDefinition" -> "RBrace" [style=dashed, color=gray];
  "structMember" -> "Semicolon" [style=dashed, color=gray];
  "enumDefinition" -> "Enum" [style=dashed, color=gray];
  "enumDefinition" -> "LBrace" [style=dashed, color=gray];
  "enumDefinition" -> "Comma" [style=dashed, color=gray];
  "enumDefinition" -> "RBrace" [style=dashed, color=gray];
  "userDefinedValueTypeDefinition" -> "Type" [style=dashed, color=gray];
  "userDefinedValueTypeDefinition" -> "Is" [style=dashed, color=gray];
  "userDefinedValueTypeDefinition" -> "Semicolon" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Public" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Private" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Internal" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Constant" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Immutable" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Transient" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Assign" [style=dashed, color=gray];
  "stateVariableDeclaration" -> "Semicolon" [style=dashed, color=gray];
  "constantVariableDeclaration" -> "Constant" [style=dashed, color=gray];
  "constantVariableDeclaration" -> "Assign" [style=dashed, color=gray];
  "constantVariableDeclaration" -> "Semicolon" [style=dashed, color=gray];
  "eventParameter" -> "Indexed" [style=dashed, color=gray];
  "eventDefinition" -> "Event" [style=dashed, color=gray];
  "eventDefinition" -> "LParen" [style=dashed, color=gray];
  "eventDefinition" -> "Comma" [style=dashed, color=gray];
  "eventDefinition" -> "RParen" [style=dashed, color=gray];
  "eventDefinition" -> "Anonymous" [style=dashed, color=gray];
  "eventDefinition" -> "Semicolon" [style=dashed, color=gray];
  "errorDefinition" -> "Error" [style=dashed, color=gray];
  "errorDefinition" -> "LParen" [style=dashed, color=gray];
  "errorDefinition" -> "Comma" [style=dashed, color=gray];
  "errorDefinition" -> "RParen" [style=dashed, color=gray];
  "errorDefinition" -> "Semicolon" [style=dashed, color=gray];
  "userDefinableOperator" -> "BitAnd" [style=dashed, color=gray];
  "userDefinableOperator" -> "BitNot" [style=dashed, color=gray];
  "userDefinableOperator" -> "BitOr" [style=dashed, color=gray];
  "userDefinableOperator" -> "BitXor" [style=dashed, color=gray];
  "userDefinableOperator" -> "Add" [style=dashed, color=gray];
  "userDefinableOperator" -> "Div" [style=dashed, color=gray];
  "userDefinableOperator" -> "Mod" [style=dashed, color=gray];
  "userDefinableOperator" -> "Mul" [style=dashed, color=gray];
  "userDefinableOperator" -> "Sub" [style=dashed, color=gray];
  "userDefinableOperator" -> "Equal" [style=dashed, color=gray];
  "userDefinableOperator" -> "GreaterThan" [style=dashed, color=gray];
  "userDefinableOperator" -> "GreaterThanOrEqual" [style=dashed, color=gray];
  "userDefinableOperator" -> "LessThan" [style=dashed, color=gray];
  "userDefinableOperator" -> "LessThanOrEqual" [style=dashed, color=gray];
  "userDefinableOperator" -> "NotEqual" [style=dashed, color=gray];
  "usingDirective" -> "Using" [style=dashed, color=gray];
  "usingDirective" -> "LBrace" [style=dashed, color=gray];
  "usingDirective" -> "Comma" [style=dashed, color=gray];
  "usingDirective" -> "RBrace" [style=dashed, color=gray];
  "usingDirective" -> "For" [style=dashed, color=gray];
  "usingDirective" -> "Mul" [style=dashed, color=gray];
  "usingDirective" -> "Global" [style=dashed, color=gray];
  "usingDirective" -> "Semicolon" [style=dashed, color=gray];
  "usingAliases" -> "As" [style=dashed, color=gray];
  "typeName" -> "LBrack" [style=dashed, color=gray];
  "typeName" -> "RBrack" [style=dashed, color=gray];
  "elementaryTypeName" -> "Address" [style=dashed, color=gray];
  "elementaryTypeName" -> "Payable" [style=dashed, color=gray];
  "elementaryTypeName" -> "Bool" [style=dashed, color=gray];
  "elementaryTypeName" -> "String" [style=dashed, color=gray];
  "elementaryTypeName" -> "Bytes" [style=dashed, color=gray];
  "elementaryTypeName" -> "SignedIntegerType" [style=dashed, color=gray];
  "elementaryTypeName" -> "UnsignedIntegerType" [style=dashed, color=gray];
  "elementaryTypeName" -> "FixedBytes" [style=dashed, color=gray];
  "elementaryTypeName" -> "Fixed" [style=dashed, color=gray];
  "elementaryTypeName" -> "Ufixed" [style=dashed, color=gray];
  "functionTypeName" -> "Function" [style=dashed, color=gray];
  "functionTypeName" -> "LParen" [style=dashed, color=gray];
  "functionTypeName" -> "RParen" [style=dashed, color=gray];
  "functionTypeName" -> "Returns" [style=dashed, color=gray];
  "dataLocation" -> "Memory" [style=dashed, color=gray];
  "dataLocation" -> "Storage" [style=dashed, color=gray];
  "dataLocation" -> "Calldata" [style=dashed, color=gray];
  "expression" -> "LBrack" [style=dashed, color=gray];
  "expression" -> "RBrack" [style=dashed, color=gray];
  "expression" -> "Colon" [style=dashed, color=gray];
  "expression" -> "Period" [style=dashed, color=gray];
  "expression" -> "Address" [style=dashed, color=gray];
  "expression" -> "LBrace" [style=dashed, color=gray];
  "expression" -> "Comma" [style=dashed, color=gray];
  "expression" -> "RBrace" [style=dashed, color=gray];
  "expression" -> "Payable" [style=dashed, color=gray];
  "expression" -> "Type" [style=dashed, color=gray];
  "expression" -> "LParen" [style=dashed, color=gray];
  "expression" -> "RParen" [style=dashed, color=gray];
  "expression" -> "Inc" [style=dashed, color=gray];
  "expression" -> "Dec" [style=dashed, color=gray];
  "expression" -> "Not" [style=dashed, color=gray];
  "expression" -> "BitNot" [style=dashed, color=gray];
  "expression" -> "Delete" [style=dashed, color=gray];
  "expression" -> "Sub" [style=dashed, color=gray];
  "expression" -> "Exp" [style=dashed, color=gray];
  "expression" -> "Mul" [style=dashed, color=gray];
  "expression" -> "Div" [style=dashed, color=gray];
  "expression" -> "Mod" [style=dashed, color=gray];
  "expression" -> "Add" [style=dashed, color=gray];
  "expression" -> "Shl" [style=dashed, color=gray];
  "expression" -> "Sar" [style=dashed, color=gray];
  "expression" -> "Shr" [style=dashed, color=gray];
  "expression" -> "BitAnd" [style=dashed, color=gray];
  "expression" -> "BitXor" [style=dashed, color=gray];
  "expression" -> "BitOr" [style=dashed, color=gray];
  "expression" -> "LessThan" [style=dashed, color=gray];
  "expression" -> "GreaterThan" [style=dashed, color=gray];
  "expression" -> "LessThanOrEqual" [style=dashed, color=gray];
  "expression" -> "GreaterThanOrEqual" [style=dashed, color=gray];
  "expression" -> "Equal" [style=dashed, color=gray];
  "expression" -> "NotEqual" [style=dashed, color=gray];
  "expression" -> "And" [style=dashed, color=gray];
  "expression" -> "Or" [style=dashed, color=gray];
  "expression" -> "Conditional" [style=dashed, color=gray];
  "expression" -> "New" [style=dashed, color=gray];
  "assignOp" -> "Assign" [style=dashed, color=gray];
  "assignOp" -> "AssignBitOr" [style=dashed, color=gray];
  "assignOp" -> "AssignBitXor" [style=dashed, color=gray];
  "assignOp" -> "AssignBitAnd" [style=dashed, color=gray];
  "assignOp" -> "AssignShl" [style=dashed, color=gray];
  "assignOp" -> "AssignSar" [style=dashed, color=gray];
  "assignOp" -> "AssignShr" [style=dashed, color=gray];
  "assignOp" -> "AssignAdd" [style=dashed, color=gray];
  "assignOp" -> "AssignSub" [style=dashed, color=gray];
  "assignOp" -> "AssignMul" [style=dashed, color=gray];
  "assignOp" -> "AssignDiv" [style=dashed, color=gray];
  "assignOp" -> "AssignMod" [style=dashed, color=gray];
  "tupleExpression" -> "LParen" [style=dashed, color=gray];
  "tupleExpression" -> "Comma" [style=dashed, color=gray];
  "tupleExpression" -> "RParen" [style=dashed, color=gray];
  "inlineArrayExpression" -> "LBrack" [style=dashed, color=gray];
  "inlineArrayExpression" -> "Comma" [style=dashed, color=gray];
  "inlineArrayExpression" -> "RBrack" [style=dashed, color=gray];
  "identifier" -> "Identifier" [style=dashed, color=gray];
  "identifier" -> "From" [style=dashed, color=gray];
  "identifier" -> "Error" [style=dashed, color=gray];
  "identifier" -> "Revert" [style=dashed, color=gray];
  "identifier" -> "Global" [style=dashed, color=gray];
  "identifier" -> "Transient" [style=dashed, color=gray];
  "identifier" -> "Layout" [style=dashed, color=gray];
  "identifier" -> "At" [style=dashed, color=gray];
  "literalWithSubDenomination" -> "SubDenomination" [style=dashed, color=gray];
  "booleanLiteral" -> "True" [style=dashed, color=gray];
  "booleanLiteral" -> "False" [style=dashed, color=gray];
  "stringLiteral" -> "NonEmptyStringLiteral" [style=dashed, color=gray];
  "stringLiteral" -> "EmptyStringLiteral" [style=dashed, color=gray];
  "hexStringLiteral" -> "HexString" [style=dashed, color=gray];
  "unicodeStringLiteral" -> "UnicodeStringLiteral" [style=dashed, color=gray];
  "numberLiteral" -> "DecimalNumber" [style=dashed, color=gray];
  "numberLiteral" -> "HexNumber" [style=dashed, color=gray];
  "block" -> "LBrace" [style=dashed, color=gray];
  "block" -> "RBrace" [style=dashed, color=gray];
  "uncheckedBlock" -> "Unchecked" [style=dashed, color=gray];
  "ifStatement" -> "If" [style=dashed, color=gray];
  "ifStatement" -> "LParen" [style=dashed, color=gray];
  "ifStatement" -> "RParen" [style=dashed, color=gray];
  "ifStatement" -> "Else" [style=dashed, color=gray];
  "forStatement" -> "For" [style=dashed, color=gray];
  "forStatement" -> "LParen" [style=dashed, color=gray];
  "forStatement" -> "Semicolon" [style=dashed, color=gray];
  "forStatement" -> "RParen" [style=dashed, color=gray];
  "whileStatement" -> "While" [style=dashed, color=gray];
  "whileStatement" -> "LParen" [style=dashed, color=gray];
  "whileStatement" -> "RParen" [style=dashed, color=gray];
  "doWhileStatement" -> "Do" [style=dashed, color=gray];
  "doWhileStatement" -> "While" [style=dashed, color=gray];
  "doWhileStatement" -> "LParen" [style=dashed, color=gray];
  "doWhileStatement" -> "RParen" [style=dashed, color=gray];
  "doWhileStatement" -> "Semicolon" [style=dashed, color=gray];
  "continueStatement" -> "Continue" [style=dashed, color=gray];
  "continueStatement" -> "Semicolon" [style=dashed, color=gray];
  "breakStatement" -> "Break" [style=dashed, color=gray];
  "breakStatement" -> "Semicolon" [style=dashed, color=gray];
  "tryStatement" -> "Try" [style=dashed, color=gray];
  "tryStatement" -> "Returns" [style=dashed, color=gray];
  "tryStatement" -> "LParen" [style=dashed, color=gray];
  "tryStatement" -> "RParen" [style=dashed, color=gray];
  "catchClause" -> "Catch" [style=dashed, color=gray];
  "catchClause" -> "LParen" [style=dashed, color=gray];
  "catchClause" -> "RParen" [style=dashed, color=gray];
  "returnStatement" -> "Return" [style=dashed, color=gray];
  "returnStatement" -> "Semicolon" [style=dashed, color=gray];
  "emitStatement" -> "Emit" [style=dashed, color=gray];
  "emitStatement" -> "Semicolon" [style=dashed, color=gray];
  "revertStatement" -> "Revert" [style=dashed, color=gray];
  "revertStatement" -> "Semicolon" [style=dashed, color=gray];
  "assemblyStatement" -> "Assembly" [style=dashed, color=gray];
  "assemblyStatement" -> "AssemblyDialect" [style=dashed, color=gray];
  "assemblyStatement" -> "AssemblyLBrace" [style=dashed, color=gray];
  "assemblyStatement" -> "YulRBrace" [style=dashed, color=gray];
  "assemblyFlags" -> "AssemblyBlockLParen" [style=dashed, color=gray];
  "assemblyFlags" -> "AssemblyFlagString" [style=dashed, color=gray];
  "assemblyFlags" -> "AssemblyBlockComma" [style=dashed, color=gray];
  "assemblyFlags" -> "AssemblyBlockRParen" [style=dashed, color=gray];
  "variableDeclarationList" -> "Comma" [style=dashed, color=gray];
  "variableDeclarationTuple" -> "LParen" [style=dashed, color=gray];
  "variableDeclarationTuple" -> "Comma" [style=dashed, color=gray];
  "variableDeclarationTuple" -> "RParen" [style=dashed, color=gray];
  "variableDeclarationStatement" -> "Assign" [style=dashed, color=gray];
  "variableDeclarationStatement" -> "Semicolon" [style=dashed, color=gray];
  "expressionStatement" -> "Semicolon" [style=dashed, color=gray];
  "mappingType" -> "Mapping" [style=dashed, color=gray];
  "mappingType" -> "LParen" [style=dashed, color=gray];
  "mappingType" -> "DoubleArrow" [style=dashed, color=gray];
  "mappingType" -> "RParen" [style=dashed, color=gray];
  "yulStatement" -> "YulLeave" [style=dashed, color=gray];
  "yulStatement" -> "YulBreak" [style=dashed, color=gray];
  "yulStatement" -> "YulContinue" [style=dashed, color=gray];
  "yulBlock" -> "YulLBrace" [style=dashed, color=gray];
  "yulBlock" -> "YulRBrace" [style=dashed, color=gray];
  "yulVariableDeclaration" -> "YulLet" [style=dashed, color=gray];
  "yulVariableDeclaration" -> "YulIdentifier" [style=dashed, color=gray];
  "yulVariableDeclaration" -> "YulAssign" [style=dashed, color=gray];
  "yulVariableDeclaration" -> "YulComma" [style=dashed, color=gray];
  "yulAssignment" -> "YulAssign" [style=dashed, color=gray];
  "yulAssignment" -> "YulComma" [style=dashed, color=gray];
  "yulIfStatement" -> "YulIf" [style=dashed, color=gray];
  "yulForStatement" -> "YulFor" [style=dashed, color=gray];
  "yulSwitchCase" -> "YulCase" [style=dashed, color=gray];
  "yulSwitchStatement" -> "YulSwitch" [style=dashed, color=gray];
  "yulSwitchStatement" -> "YulDefault" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulFunction" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulIdentifier" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulLParen" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulComma" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulRParen" [style=dashed, color=gray];
  "yulFunctionDefinition" -> "YulArrow" [style=dashed, color=gray];
  "yulPath" -> "YulIdentifier" [style=dashed, color=gray];
  "yulPath" -> "YulPeriod" [style=dashed, color=gray];
  "yulPath" -> "YulEVMBuiltin" [style=dashed, color=gray];
  "yulFunctionCall" -> "YulIdentifier" [style=dashed, color=gray];
  "yulFunctionCall" -> "YulEVMBuiltin" [style=dashed, color=gray];
  "yulFunctionCall" -> "YulLParen" [style=dashed, color=gray];
  "yulFunctionCall" -> "YulComma" [style=dashed, color=gray];
  "yulFunctionCall" -> "YulRParen" [style=dashed, color=gray];
  "yulBoolean" -> "YulTrue" [style=dashed, color=gray];
  "yulBoolean" -> "YulFalse" [style=dashed, color=gray];
  "yulLiteral" -> "YulDecimalNumber" [style=dashed, color=gray];
  "yulLiteral" -> "YulStringLiteral" [style=dashed, color=gray];
  "yulLiteral" -> "YulHexNumber" [style=dashed, color=gray];
  "yulLiteral" -> "YulHexStringLiteral" [style=dashed, color=gray];
}
