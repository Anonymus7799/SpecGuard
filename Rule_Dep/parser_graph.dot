digraph ParserRuleDependencies {
  rankdir=LR;
  node [shape=box, fillcolor=lightblue, style=filled];

  "sourceUnit" -> "pragmaDirective";
  "sourceUnit" -> "importDirective";
  "sourceUnit" -> "usingDirective";
  "sourceUnit" -> "contractDefinition";
  "sourceUnit" -> "interfaceDefinition";
  "sourceUnit" -> "libraryDefinition";
  "sourceUnit" -> "functionDefinition";
  "sourceUnit" -> "constantVariableDeclaration";
  "sourceUnit" -> "structDefinition";
  "sourceUnit" -> "enumDefinition";
  "sourceUnit" -> "userDefinedValueTypeDefinition";
  "sourceUnit" -> "errorDefinition";
  "sourceUnit" -> "eventDefinition";
  "importDirective" -> "path";
  "importDirective" -> "identifier";
  "importDirective" -> "symbolAliases";
  "importAliases" -> "identifier";
  "symbolAliases" -> "importAliases";
  "contractDefinition" -> "identifier";
  "contractDefinition" -> "expression";
  "contractDefinition" -> "inheritanceSpecifierList";
  "contractDefinition" -> "contractBodyElement";
  "interfaceDefinition" -> "identifier";
  "interfaceDefinition" -> "inheritanceSpecifierList";
  "interfaceDefinition" -> "contractBodyElement";
  "libraryDefinition" -> "identifier";
  "libraryDefinition" -> "contractBodyElement";
  "inheritanceSpecifierList" -> "inheritanceSpecifier";
  "inheritanceSpecifier" -> "identifierPath";
  "inheritanceSpecifier" -> "callArgumentList";
  "contractBodyElement" -> "constructorDefinition";
  "contractBodyElement" -> "functionDefinition";
  "contractBodyElement" -> "modifierDefinition";
  "contractBodyElement" -> "fallbackFunctionDefinition";
  "contractBodyElement" -> "receiveFunctionDefinition";
  "contractBodyElement" -> "structDefinition";
  "contractBodyElement" -> "enumDefinition";
  "contractBodyElement" -> "userDefinedValueTypeDefinition";
  "contractBodyElement" -> "stateVariableDeclaration";
  "contractBodyElement" -> "eventDefinition";
  "contractBodyElement" -> "errorDefinition";
  "contractBodyElement" -> "usingDirective";
  "namedArgument" -> "identifier";
  "namedArgument" -> "expression";
  "callArgumentList" -> "expression";
  "callArgumentList" -> "namedArgument";
  "identifierPath" -> "identifier";
  "modifierInvocation" -> "identifierPath";
  "modifierInvocation" -> "callArgumentList";
  "parameterList" -> "parameterDeclaration";
  "parameterDeclaration" -> "typeName";
  "parameterDeclaration" -> "dataLocation";
  "parameterDeclaration" -> "identifier";
  "constructorDefinition" -> "parameterList";
  "constructorDefinition" -> "modifierInvocation";
  "constructorDefinition" -> "block";
  "overrideSpecifier" -> "identifierPath";
  "functionDefinition" -> "identifier";
  "functionDefinition" -> "parameterList";
  "functionDefinition" -> "visibility";
  "functionDefinition" -> "stateMutability";
  "functionDefinition" -> "modifierInvocation";
  "functionDefinition" -> "overrideSpecifier";
  "functionDefinition" -> "block";
  "modifierDefinition" -> "identifier";
  "modifierDefinition" -> "parameterList";
  "modifierDefinition" -> "overrideSpecifier";
  "modifierDefinition" -> "block";
  "fallbackFunctionDefinition" -> "parameterList";
  "fallbackFunctionDefinition" -> "stateMutability";
  "fallbackFunctionDefinition" -> "modifierInvocation";
  "fallbackFunctionDefinition" -> "overrideSpecifier";
  "fallbackFunctionDefinition" -> "block";
  "receiveFunctionDefinition" -> "modifierInvocation";
  "receiveFunctionDefinition" -> "overrideSpecifier";
  "receiveFunctionDefinition" -> "block";
  "structDefinition" -> "identifier";
  "structDefinition" -> "structMember";
  "structMember" -> "typeName";
  "structMember" -> "identifier";
  "enumDefinition" -> "identifier";
  "userDefinedValueTypeDefinition" -> "identifier";
  "userDefinedValueTypeDefinition" -> "elementaryTypeName";
  "stateVariableDeclaration" -> "typeName";
  "stateVariableDeclaration" -> "overrideSpecifier";
  "stateVariableDeclaration" -> "identifier";
  "stateVariableDeclaration" -> "expression";
  "constantVariableDeclaration" -> "typeName";
  "constantVariableDeclaration" -> "identifier";
  "constantVariableDeclaration" -> "expression";
  "eventParameter" -> "typeName";
  "eventParameter" -> "identifier";
  "eventDefinition" -> "identifier";
  "eventDefinition" -> "eventParameter";
  "errorParameter" -> "typeName";
  "errorParameter" -> "identifier";
  "errorDefinition" -> "identifier";
  "errorDefinition" -> "errorParameter";
  "usingDirective" -> "identifierPath";
  "usingDirective" -> "usingAliases";
  "usingDirective" -> "typeName";
  "usingAliases" -> "identifierPath";
  "usingAliases" -> "userDefinableOperator";
  "typeName" -> "elementaryTypeName";
  "typeName" -> "functionTypeName";
  "typeName" -> "mappingType";
  "typeName" -> "identifierPath";
  "typeName" -> "typeName" [color=red, penwidth=2];
  "typeName" -> "expression";
  "functionTypeName" -> "parameterList";
  "functionTypeName" -> "visibility";
  "functionTypeName" -> "stateMutability";
  "variableDeclaration" -> "typeName";
  "variableDeclaration" -> "dataLocation";
  "variableDeclaration" -> "identifier";
  "expression" -> "expression" [color=red, penwidth=2];
  "expression" -> "identifier";
  "expression" -> "namedArgument";
  "expression" -> "callArgumentList";
  "expression" -> "typeName";
  "expression" -> "assignOp";
  "expression" -> "tupleExpression";
  "expression" -> "inlineArrayExpression";
  "expression" -> "literal";
  "expression" -> "literalWithSubDenomination";
  "expression" -> "elementaryTypeName";
  "tupleExpression" -> "expression";
  "inlineArrayExpression" -> "expression";
  "literal" -> "stringLiteral";
  "literal" -> "numberLiteral";
  "literal" -> "booleanLiteral";
  "literal" -> "hexStringLiteral";
  "literal" -> "unicodeStringLiteral";
  "literalWithSubDenomination" -> "numberLiteral";
  "block" -> "statement";
  "block" -> "uncheckedBlock";
  "uncheckedBlock" -> "block";
  "statement" -> "block";
  "statement" -> "simpleStatement";
  "statement" -> "ifStatement";
  "statement" -> "forStatement";
  "statement" -> "whileStatement";
  "statement" -> "doWhileStatement";
  "statement" -> "continueStatement";
  "statement" -> "breakStatement";
  "statement" -> "tryStatement";
  "statement" -> "returnStatement";
  "statement" -> "emitStatement";
  "statement" -> "revertStatement";
  "statement" -> "assemblyStatement";
  "simpleStatement" -> "variableDeclarationStatement";
  "simpleStatement" -> "expressionStatement";
  "ifStatement" -> "expression";
  "ifStatement" -> "statement";
  "forStatement" -> "simpleStatement";
  "forStatement" -> "expressionStatement";
  "forStatement" -> "expression";
  "forStatement" -> "statement";
  "whileStatement" -> "expression";
  "whileStatement" -> "statement";
  "doWhileStatement" -> "statement";
  "doWhileStatement" -> "expression";
  "tryStatement" -> "expression";
  "tryStatement" -> "parameterList";
  "tryStatement" -> "block";
  "tryStatement" -> "catchClause";
  "catchClause" -> "identifier";
  "catchClause" -> "parameterList";
  "catchClause" -> "block";
  "returnStatement" -> "expression";
  "emitStatement" -> "expression";
  "emitStatement" -> "callArgumentList";
  "revertStatement" -> "expression";
  "revertStatement" -> "callArgumentList";
  "assemblyStatement" -> "assemblyFlags";
  "assemblyStatement" -> "yulStatement";
  "variableDeclarationList" -> "variableDeclaration";
  "variableDeclarationTuple" -> "variableDeclaration";
  "variableDeclarationStatement" -> "variableDeclaration";
  "variableDeclarationStatement" -> "expression";
  "variableDeclarationStatement" -> "variableDeclarationTuple";
  "expressionStatement" -> "expression";
  "mappingType" -> "mappingKeyType";
  "mappingType" -> "identifier";
  "mappingType" -> "typeName";
  "mappingKeyType" -> "elementaryTypeName";
  "mappingKeyType" -> "identifierPath";
  "yulStatement" -> "yulBlock";
  "yulStatement" -> "yulVariableDeclaration";
  "yulStatement" -> "yulAssignment";
  "yulStatement" -> "yulFunctionCall";
  "yulStatement" -> "yulIfStatement";
  "yulStatement" -> "yulForStatement";
  "yulStatement" -> "yulSwitchStatement";
  "yulStatement" -> "yulFunctionDefinition";
  "yulBlock" -> "yulStatement";
  "yulVariableDeclaration" -> "yulExpression";
  "yulVariableDeclaration" -> "yulFunctionCall";
  "yulAssignment" -> "yulPath";
  "yulAssignment" -> "yulExpression";
  "yulAssignment" -> "yulFunctionCall";
  "yulIfStatement" -> "yulExpression";
  "yulIfStatement" -> "yulBlock";
  "yulForStatement" -> "yulBlock";
  "yulForStatement" -> "yulExpression";
  "yulSwitchCase" -> "yulLiteral";
  "yulSwitchCase" -> "yulBlock";
  "yulSwitchStatement" -> "yulExpression";
  "yulSwitchStatement" -> "yulSwitchCase";
  "yulSwitchStatement" -> "yulBlock";
  "yulFunctionDefinition" -> "yulBlock";
  "yulFunctionCall" -> "yulExpression";
  "yulLiteral" -> "yulBoolean";
  "yulExpression" -> "yulPath";
  "yulExpression" -> "yulFunctionCall";
  "yulExpression" -> "yulLiteral";
}
